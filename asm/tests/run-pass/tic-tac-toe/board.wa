################################################################################
#
# Routines for managing the representation of the board.
#
################################################################################

# The number of rows on a tic-tac-toe board
.const ROWS 3
# The number of columns on a tic-tac-toe board
.const COLS 3
# The number of tiles on a tic-tac-toe board
.const TILES 9
# A value representing the absence of a value (like null)
.const NONE 0
# The constant value used to repesent piece X
.const PIECE_X 1
# The constant value used to repesent piece O
.const PIECE_O 2
# Total size of the representation of the board
# TILES bytes + 1 byte for current piece (PIECE_X or PIECE_O)
.const BOARD_BYTES 10

################################################################################
#
# Initializes the tic-tac-toe board whose address is in $1
#
################################################################################
init_board:
  push $fp
  mov $fp, $sp

  # Push registers used in this routine
  push $1
  push $2

  # Initialize the board tiles to be empty

  # Address of one past the end of tiles
  mov $2, $1
  add $2, TILES

init_board_tiles:
  cmp $1, $2
  je init_board_current_piece

  # Store NONE in the tile to represent that this tile is empty
  store1 $1, NONE

  add $1, 1
  jmp init_board_tiles

init_board_current_piece:
  # Start the game with X as the current piece
  store1 $1, PIECE_X

  # Pop registers used in this routine
  pop $2
  pop $1

  pop $fp
  ret

################################################################################
#
# Modifies the tic-tac-toe board whose address is in $1 by placing the current
# piece at the position (0-8) stored in $2. Sets the current piece to the
# opposite piece.
#
# This routine assumes that $2 is in the range 0-8 and does *not* check if the
# requested tile is empty before overwriting it.
#
################################################################################
make_move:
  push $fp
  mov $fp, $sp

  # Push registers used in this routine
  push $1
  push $2
  push $3
  push $4

  # Read the current piece into $3
  mov $3, $1
  add $3, TILES
  loadu1 $4, $3

  # Set the selected tile to the current piece
  add $2, $1
  store1 $2, $4

  # Set the current piece to the opposite piece
  # This code works because PIECE_X and PIECE_O are consecutive integers
  mov $2, PIECE_O
  sub $2, $4
  add $2, PIECE_X
  store1 $3, $2

  # Pop registers used in this routine
  pop $4
  pop $3
  pop $2
  pop $1

  pop $fp
  ret

################################################################################
#
# Gets the current piece from the board whose address is in $1 and stores
# PIECE_X or PIECE_O in $2.
#
################################################################################
current_piece:
  push $fp
  mov $fp, $sp

  mov $2, $1
  add $2, TILES
  loadu1 $2, $2

  pop $fp
  ret

################################################################################
#
# Checks the board whose address is in $1 to see if the game has been won.
# Stores NONE, PIECE_X, or PIECE_O in $2.
#
################################################################################
check_winner:
  push $fp
  mov $fp, $sp

  # Push registers used in this routine
  push $3

  mov $2, NONE #TODO

  # Pop registers used in this routine
  pop $3

  pop $fp
  ret

################################################################################
#
# Given a board whose address is in $1, counts the empty tiles and places the
# count (between 0 and 9) into $2.
#
################################################################################
check_board_empty_tiles:
  push $fp
  mov $fp, $sp

  # Push registers used in this routine
  push $1
  push $3
  push $4

  # There can be up to TILES empty tiles
  mov $2, TILES

  # The address one past the end of the tiles
  mov $3, $1
  add $3, $2

check_board_empty_tiles_loop:
  cmp $1, $3
  jae check_board_empty_tiles_done

  # Load the tile value
  loadu1 $4, $1

  # Check if empty
  cmp $4, NONE
  je check_board_empty_tiles_continue

  # Found non-empty tile
  sub $2, 1

check_board_empty_tiles_continue:
  # Continue to the next tile
  add $1, 1

  jmp check_board_empty_tiles_loop

check_board_empty_tiles_done:
  # Pop registers used in this routine
  pop $4
  pop $3
  pop $1

  pop $fp
  ret
