//! wolf-vm - the wolf virtual machine
//!
//! Runs machine code generated from The Wolf Assembly Language

#![deny(unused_must_use)]

use std::path::PathBuf;
use std::fs::File;

use anyhow::Context;
use structopt::StructOpt;
use wolf_asm::executable::Executable;
use wolf_vm::{
    memory::Memory,
    write_memory::WriteMemory,
    registers::Registers,
    flags::Flags,
};

const MACHINE_MEMORY: usize = 4 * 1024; // 4 kb

/// The address where program execution should start
const START_ADDR: usize = 0;

#[derive(Debug, StructOpt)]
#[structopt(name = "wolf-vm", about)]
struct VMOptions {
    /// The executable file generated by the wolf-asm assembler
    #[structopt(name = "input", parse(from_os_str))]
    executable_path: PathBuf,
}

fn main() -> anyhow::Result<()> {
    let VMOptions {executable_path} = VMOptions::from_args();

    let executable_file = File::open(&executable_path)
        .with_context(|| format!("Failed to read executable: `{}`", executable_path.display()))?;
    let exec: Executable = bincode::deserialize_from(executable_file)
        .with_context(|| format!("Failed to deserialize executable: `{}`", executable_path.display()))?;

    let mut mem = Memory::new(MACHINE_MEMORY);
    // Write the executable at the starting address
    exec.write_into(&mut mem, START_ADDR)
        .context("Failed to load executable into memory")?;

    let mut regs = Registers::default();
    let mut flags = Flags::default();

    let mut cpu = Cpu::new(START_ADDR);

    Ok(())
}
